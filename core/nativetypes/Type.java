package core.nativetypes;

import core.Core;
import util.RG;
import util.DataTransform;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Collectors;

public class Type{
	public String name;
	public List<String> subtypes = new ArrayList<>();
	public Chain chain;
	public List<Link> links = new ArrayList<>();
	
	public Type(){
		
	}
	
	public Type(String name, List<String> subtypes){
		this.name = name;
		this.subtypes = subtypes;
	}
	
	public Type(String name, List<String> subtypes, Chain chain){
		this.name = name;
		this.subtypes = subtypes;
		this.chain = chain;
	}
	
	public Type(String name, List<String> subtypes, Chain chain, List<Link> links){
		this.name = name;
		this.subtypes = subtypes;
		this.chain = chain;
		this.links = links;
	}
	
	public static int parse(Core core, String typeName, String[] subtypes){
		if("".equals(typeName)) return -1;
		if(subtypes.length == 0) return -1;
		
		core.types.add(new Type(typeName, Arrays.asList(subtypes)));
		
		return 0;
	}
	
	public static int bindLink(Core core, String[] typeAndLink, String[] domainAndCodomain){
		Optional<Type> optType = core.getTypeByName(typeAndLink[0]);
		
		if(!optType.isPresent()) return -1;
		
		Optional<Link> optLink = core.getLinkByName(typeAndLink[1]);
		
		if(!optLink.isPresent()) return -1;
		
		Link link = optLink.get().getDeepCopy();
		
		try{
			link.x = Integer.parseInt(domainAndCodomain[0].trim());
			link.y = Integer.parseInt(domainAndCodomain[1].trim());
		}
		catch(Exception e){
			return -1;
		}
		
		optType.get().links.add(link);
		
		return 0;
	}
	
	public static int unbindLink(Core core, String[] typeAndLink){
		Optional<Type> optType = core.getTypeByName(typeAndLink[0]);
		
		if(!optType.isPresent()) return -1;
		
		Optional<Link> optLink = core.getLinkByName(typeAndLink[1]);
		
		if(!optLink.isPresent()) return -1;
		
		optType.get().links.remove(optLink.get());
		
		return 0;
	}
	
	// We use instanceIndex as a sample offset (along with sample width defined with config) when we need to
	// sample function like 'sin' because of existing links
	// Additionally, we use it to control id numbers when generating code
	public void generateInstance(Core core, int instanceIndex){
		if(chain != null)
			for(Type t : chain.chainers)
				t.generateInstance(core, instanceIndex);
		
		if(subtypes.size() == 0) return;
		
		// WE ASSUME THAT ID IS INTEGER
		
		// Form starting part of the string (the rest is appened in main for loop and after it)
		StringBuilder sb = new StringBuilder();
		sb.append("insert into ");
		// If the database name is defined
		if(!"".equals(core.config.databaseName))
			sb.append("`" + core.config.databaseName + "`.");
		sb.append("`" + name + "` values(");
		sb.append(core.config.autoIncrementBase + instanceIndex);
		
		if(subtypes.size() != 1){
			String[] parts = null;
			RG rg = new RG();
			DataTransform dt = new DataTransform(core);
			String value = null;
			
			// First go through all binded links and generate list containing data for binded fields
			// After that, in the main for loop, we should check whether data for specific field index is already
			// generated, and only generate random data if it is not
			
			// When using link function to generate values of two fields, field corresponding
			// to x is equal to (instanceIndex*core.config.sampleWidth)
			// y is equal to generated value
			Link temp = null;
			double generatedValue = 0;
			
			// Make array for storing values generated by functions defined in given links
			// Also, initialize array to some value (here 999.999) that is unlikely to appear among generated values
			// This is for the sake of recognizing whether value for specific index has been generated
			double[] subtypesValues = new double[subtypes.size()];
			for(int i = 0; i < subtypesValues.length; ++i)
				subtypesValues[i] = 999.999;
			
			for(int i = 0; i < links.size(); ++i){
				temp = links.get(i);
				generatedValue = Link.generateValue(core, temp, instanceIndex);
				
				// If we bind two actual type fields
				if(temp.x != -1){
					// Save values to array representing indices of subtypes
					// We will use this info in main for loop
					// If there is value present on the given index, then we will use that insead of random value
					subtypesValues[temp.x] = core.config.sampleWidth * instanceIndex;
					subtypesValues[temp.y] = generatedValue;
				}
				// If we bind abstract field with actual field
				else{
					subtypesValues[temp.y] = generatedValue;
				}
			}
			
			// MAIN FOR LOOP (further forms code strings)
			for(int i = 1; i < subtypes.size(); ++i){
				sb.append(", ");
				
				parts = subtypes.get(i).split(":");
				
				// If the given subtype represents chained field
				if(parts.length == 2 && "chained".equals(parts[1])){
					// We give it value that corresponds to instanceIndex starting from auto increment base
					// We do this for all chained fields, since of chainer types will also be given the same
					// auto increments base and instanceIndex
					// (this way we don't need to define by which type is the given field chained)
					sb.append(core.config.autoIncrementBase + instanceIndex);
				}
				else{
					// If the value is generated based on defined link bound to this type then use that value (in corresponding form)
					// If not, then generate random value
					if(subtypesValues[i] != 999.999){
						// WE NEED TO CONVERT GENERATED VALUES TO CORRESPONDING TYPE BEFORE INSERTING THEM INTO CODE
						value = dt.doubleToSubtypeString(parts[0].trim(), subtypesValues[i]);
					}
					else{
						// All values, no matter the type, are returned as string since we are generating database code
						value = rg.getRandom(parts[0].trim());
					}
					
					sb.append(value);
				}
			}
		}
		
		sb.append(");");
		
		System.out.println(sb);
	}
	
	public String getBindedLinksPrintString(){
		StringBuilder sb = new StringBuilder();
		sb.append(name + " [binds] {\n");
		links.forEach(l -> sb.append("  " + l.name + ", " + l.x + ", " + l.y + "\n"));
		sb.append("}\n");
		
		return sb.toString();
	}
	
	@Override
	public String toString(){
		StringBuilder sb = new StringBuilder();
		
		sb.append(name + " {\n");
		for(String subtype : subtypes)
			sb.append("  " + subtype + "\n");
		sb.append("}\n");
		
		return sb.toString();
	}
}